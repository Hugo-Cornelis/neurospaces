#summary (In Pogress) This is a guide on how to add a swig perl binding to heccer.
#labels G3Doc

= Introduction =

In a previous example we created a simulation object called PulseGen for use in GENESIS 3 simulations as a callable object.  Here we will implement the necessary bindings to make the object callable from perl using SWIG. This will allow it to easily be used in the perl based applications of GENESIS such as the gshell and ssp.


----

= Source files =

The PulseGen implementation currently resides in the Heccer package in the files:

{{{
pulsegen.c
heccer/pulsegen.h
}}}


== Perl SWIG files ==

Heccer has two files where SWIG bindings are implemented:

{{{
glue/swig/perl/heccer.i
glue/swig/perl/Heccer.pm
}}}

heccer.i is a SWIG interface file which generates C code that we can compile and link against Perl headers and libraries. 

Heccer.pm is a Perl module which contains higher level function calls to the previously mentioned interface.

We will add our own bindings to these files to make the PulseGen object callable.

=== SWIG interface file heccer.i ===

First we need to include our _heccer/pulsegen.h_ header in the interface file in two places. At the top of the file with the other includes we add:

{{{
#include "heccer/pulsegen.h"
}}} 

For the module declaration we add it near the end like this:

{{{
%include "heccer/pulsegen.h"
}}}

Next we need to declare a couple of functions for retrieving object data, and for performing a step in a simulation. These functions are considered to be _low level_ functions.

This function will return a pointer to a _simobj_PulseGen_ data struct (defined in heccer/pulsegen.h) so that the calling process can get access to the objects data:

{{{
void * pulse_gen_get_driver_data(struct simobj_PulseGen *ppg)
{
    return((void *)ppg);
}
}}}

This function will be called when performing a step in a simulation:

{{{
void * pulse_gen_get_driver_method(struct simobj_PulseGen *ppg)
{
    return((void *)PulseGenSingleStep);
}
}}}



=== Perl module Heccer.pm ===

In this section we define higher level functions that make use of the functions we defined in out SWIG interface file. These functions will be defined within a Perl module and be callable by other Perl programs. 

In our implementation files for our simulation object, pulsegen.c and heccer/pulsegen.h, we have a set of functions required for running a simulation:

{{{
struct simobj_PulseGen * PulseGenNew(char *pcName);

int PulseGenFinish(struct simobj_PulseGen *ppg);

int PulseGenAddInput(struct simobj_PulseGen *ppg, void *pvInput);

int PulseGenAddVariable(struct simobj_PulseGen *ppg, void *pvOutput);

int PulseGenReset(struct simobj_PulseGen *ppg);

int PulseGenSingleStep(struct simobj_PulseGen *ppg, double dTime);

int PulseGenSetFields
(
 struct simobj_PulseGen *ppg,
 double dLevel1,
 double dWidth1,
 double dDelay1,
 double dLevel2,
 double dWidth2,
 double dDelay2,
 int iTriggerMode,
 double *pdPulseOut
 );
}}}

In our Perl module we want to create a 1-to-1 correspondence for each function. The file _glue/swig/perl/Heccer.pm_ contains declarations for packages along with their accompanying functions. 

We declare a  new package and then, using an existing working example for PerfectClamp, we create identical calls to our PulseGen.

{{{
package Heccer::PulseGen;


BEGIN { our @ISA = qw(Heccer::Glue); }


sub add
{
    my $self = shift;

    my $options = shift;

    my $backend = $self->backend();

    my $name
	= $options->{service_request}->{component_name}
	    . "__"
		. $options->{service_request}->{field};

    $name =~ s/\//____/g;

    my $result = $backend->PulseGenAddVariable($options->{address});

    return $result;
}


sub finish
{
    my $self = shift;

    # close files, free memory

    my $backend = $self->backend();

    $backend->PulseGenFinish();
}


sub get_driver
{
    my $self = shift;

    my $result
	= {
	   data => $self->{backend}->pulse_gen_get_driver_data(),
	   method => $self->{backend}->pulse_gen_get_driver_method(),
# 	   data => $self->{backend},
# 	   method => \&SwiggableHeccer::PerfectClampSingleStep,
	  };

    return $result;
}


sub get_time_step
{
    my $self = shift;

    # a perfect clamp object does not have a time step

    return undef;
}


sub initiate
{
    my $self = shift;

    #t perhaps need to set the command voltage here ?
}


sub new
{
    my $package = shift;

    my $options = shift;

    my $self = { %$options, };

    bless $self, $package;

    if (!defined $self->{name})
    {
	$self->{name} = "a pc";
    }

    $self->{backend} = SwiggableHeccer::PulseGenNew($self->{name});

    if (!defined $self->{backend})
    {
	return undef;
    }

    # make distinction between command_filename and command voltage option

    if (defined $options->{command})
    {
	my $backend = $self->backend();

	$backend->PulseGenSetFields($options->{command}, undef);
    }
    elsif (defined $options->{filename})
    {
	my $backend = $self->backend();

	#! the command voltage is ignored in this case, use an
	#! unreasonable value to make result invalid if it would be used
	#! (due to a bug).

	$backend->PulseGenSetFields(-10000, $options->{filename});
    }
    else
    {
	return "Heccer::PulseGen constructor: cannot construct a perfect clamp without command voltage and without a filename";
    }

    return $self;
}


sub report
{
    my $self = shift;

    #t nothing I guess ?
}


sub step
{
    my $self = shift;

    my $scheduler = shift;

    my $options = shift;

    my $backend = $self->backend();

    my $result = $backend->PulseGenSingleStep($options->{steps});

    return $result;
}
}}}


The function *sub add* is for adding a solved variable that will be callable by Heccer or other external packages. The code will look 
----