#summary Adding a pulse object to the model-container

= Introduction =

This is essentially a developer blogpost to detail my experience adding a new object to the model-container. 


= Briefing =

First began by reading up on what documentation was available. The document doc/HOWTO.outline in model-container source code contains a section titled *Add new components* which gives a rough outline of the procedure. 

= Adding the Pulse object =

The following subheadings are in order of execution.

=== Adding a new tokenizer ===

First I added a new tokenizer to the analyzer.l file:

{{{
pulse		{	return(TOKEN_PULSE);	}
}}}


=== Add a new token ===

Added a new token to the description.tokens file located in _hierarchy/output/symbols/_ like so:

{{{
%token TOKEN_PULSE
}}}

=== Adding a parser rule ===

A series of grammar rules must now be added to parser.rules file:


At the top of the file there is a union. In this union I add a symbol for my pulse object:

{{{
struct symtab_Pulse * ppulse;
}}}

The prefix p for pulse indicates that this is a pointer. 


Now some more declarations must be added for the lexer. Copying the format of the current declarations you will need to add a block like this for our pulse object:

{{{
%type <phsle> PulseSymbol
%type <ppulse> PulseSectionFront
%type <ppulse> PulseSectionFront1
%type <pidin> PulseSectionFront2
%type <ppulse> PulseDescription
%type <phsle> PulseComponent
}}}



----
The next step is to add a rule for each of the declarations we just declared so that the parser knows what to do with them. 

We need to add a rule for the PulseSymbol:

{{{

PulseSymbol
	:
		PulseSection
		{
#line
		    //- put symbol table element on stack

		    $$ = &$1->bio.ioh.iol.hsle;
		}
}}}

The pulse symbol uses a Bio Component symbol. 

----

We add a rule for PulseDescription:
{{{
PulseDescription	/* <ppulse> */
	:
		{
#line

		    $$ = ParserContextGetActual((PARSERCONTEXT *)pacParserContext);
		}
	|
		PulseDescription
		ChildSectionOptionalInputOptionalParameters
		{
#line
		    //- link children

		    if ($2)
		    {
			SymbolAddChild(&$1->bio.ioh.iol.hsle, $2);
		    }

		    //- reset actual symbol

		    ParserContextSetActual
			((PARSERCONTEXT *)pacParserContext,
			 &$1->bio.ioh.iol.hsle);

		    //- put symbol description on stack

		    $$ = $1;
		}
	|
		PulseDescription
		Parameters
		{
#line
		    //- link parameters

		    SymbolParameterLinkAtEnd(&$1->bio.ioh.iol.hsle, $2);

		    //- reset actual symbol

		    ParserContextSetActual
			((PARSERCONTEXT *)pacParserContext,
			 &$1->bio.ioh.iol.hsle);

		    //- put symbol on stack

		    $$ = $1;
		}
	;

}}}

----
A rule for PulseSectionEnd:

{{{
PulseSectionEnd
	:
		EndPushedPidin
		TOKEN_PULSE
		{
#line
		}
	;
}}}

----

A rule for PulseSectionFront:

{{{
PulseSectionFront	/* <ppulse> */
	:
		PulseSectionFront1
		PulseSectionFront2
		{
#line

		    //- prepare struct for symbol table

		    $$ = $1;

		    //- set actual symbol

		    ParserContextSetActual
			((PARSERCONTEXT *)pacParserContext,
			 &$$->bio.ioh.iol.hsle);

		    //- assign name to symbol

		    SymbolSetName(&$$->bio.ioh.iol.hsle, $2);
		}
	;
}}}

----

Rule for PulseSectionFront1:

{{{
PulseSectionFront1	/* <ppulse> */
	:
		TOKEN_PULSE
		{
#line

		    //- prepare struct for symbol table

		    $$ = PulseCalloc();

		    //- set actual symbol

		    ParserContextSetActual
			((PARSERCONTEXT *)pacParserContext,
			 &$$->bio.ioh.iol.hsle);
		}
	;
}}}

Note that this called PulseCalloc, which must be defined for this to work.

----

Rule for PulseSectionFront2:

{{{
PulseSectionFront2	/* <ppulse> */
	:
		IdentifierOptionIndexPushedPidin
		{
#line

		    //- put identifier on stack

		    $$ = $1;
		}
	;
}}}

----

Rule for PulseSection:

{{{
PulseSection	/* <ppulse> */
	:
		PulseSectionFront
			InputOutputRelations
			OptionalItemInputRelations
			PulseDescription
		PulseSectionEnd
		{
#line
		    //- link input/output relations

		    SymbolAssignBindableIO(&$4->bio.ioh.iol.hsle, $2);

		    //- bind I/O relations

		    SymbolAssignInputs(&$4->bio.ioh.iol.hsle, $3);

		    //- put finished section info on stack

		    $$ = $4;
		}
	;
}}}


=== Creating Source Files ===

Now souce files which had the appropriate data structures and functions must be created. Here we use the pool.c and pool.h file as a template so we make copies.

pool.c is located in the _components_ directory, and pool.h is located in _neurospaces/components_. 

*cp components/pool.c components/pulse.c*

*cp neurospaces/components/pool.h neurospaces/components/pulse.h*

Now change all references of pool to pulse with appropriate case. This is a good starting point as all that's needed is to determine which parameters and functions you with to add.

=== Adding to compilation ===

To have your new pulse object compile into the model-container you must add to some of the existing build targets in the top level *Makefile.am* file.

In the target _libneurospacesread_a_SOURCES_ you must add:

{{{
	components/pulse.c \
}}}

The target _nobase_include_HEADERS_ add:

{{{
	neurospaces/components/pulse.h \
}}}

The target _libneurospacesread.so_ add:

{{{
	pulse.o \
}}}